'''
1、函数的定义是，把一段代码封装起来，方便我们使用，会接回输入，返回结果
我们来看一下函数的基本结构，我们用def来定义一个函数，函数的命名跟变量的命名规则是一样的，只能包含大小写字母，数字，下划线，以及不能以数字开头，而且后面要加()

def example():
    print('函数的结构')

函数的定义与调用形式
一:定义函数三种形式
1、有参：需要根据外部传进来的参数，才能执行相应的逻辑，比如统计长度，求最大值最小值
2、无参：应用场景仅仅只是执行一些操作，比如与用户交互，打印
3、空函数：设计代码结构
'''
# 有参函数
def func(x):
    pass
func(1)
# 无参函数
def bar():
    pass
bar()
# 空函数
def shopping():
    pass
'''

二:函数调用的三种形式
函数的调用：函数名加括号
1 先找到名字
2 根据名字调用代码

register() # 1，语句形式(单纯的语句操作，没有返回值)

def max2(x,y):
    if x > y:
        return x
    else:
        return y
res=max2(10,20)*12 # 2，表达式（可以+-*/）

res=max2(max2(10,20),30) # 3，将函数的调用当作参数传给另外一个函数
print(res)


函数的返回值return
注意点:
1. 函数的返回值没有类型限制
2. 函数的返回值没有个数限制

return返回值的三个功能
2.1 返回多个值: 多个返回值用逗号分隔开,返回的是元组形式
def func():
    print('from func')
    return 1,1.1,'hello',[1,2,3]
res=func()
print(res,type(res))
2.2 返回1个值: 返回的就是该值本身
def func():
    return 123
res=func()
print(res,type(res))
2.3 返回0个值或者干脆没有return: 返回None
def func():
    # return
    pass
res=func()
print(res)

return除了有返回值的功能,还有结束函数执行的的功能
函数内可以有多个return,但只要执行一次,整个函数就立即结束,并且将return后的值返回
def func():
    print(1)
    return
    print(2)
    return
    print(3)
func()


函数参数的使用

函数的参数
一 形参与实参
#形参即变量名，实参即变量值，函数调用时，将值绑定到变量名上，函数调用结束，解除绑定

一: 函数的参数分为两大类:
形式参数(形参): 在定义函数阶段,括号内定义的参数/变量名 称为形参
实际参数(实参): 在调用函数阶段,括号内传入的值/变量值 称为实参
ps: 在调用函数阶段会将实参(值)的值绑定给形参(变量名),\
                  这种绑定关系只在调用函数时生效,在函数执行完毕后就会解除绑定

二: 细分:
1. 位置\参数:
1.1 位置形参: 在定义阶段,按照从左到右的顺序依次定义的形参称之为位置形参
特点: 但凡时按照位置定义的形参,必须被传值,多一个不行少一个也不行
1.2 位置实参: 在调用阶段,按照从左到右的顺序依次传入的值称之为位置实参
特点:与形参一一对应
def func(x,y,z):
    print(x,y,z)
func(2,1,4)

2. 关键字实参: 在调用阶段,按照key=value的形式定义的实参称之为关键字实参
特点: 可以完全打乱顺序,但仍然能为指定的形参传值(总结:指名道姓地为指定的形参传值)
实参的形式可以是位置实参与关键字实参混合使用,但是必须遵循原则
1.位置实参必须放在关键字实参的前面
2.不能对同一个形参重复传值
func(1,z=3,y=2)
func(z=3,1,y=2) #错误
func(1,z=3,x=2,y=3) #错误

3. 默认形参：在定义阶段，就已经为形参赋值，该形参称之为默认参数
特点
1. 定义阶段就已经有值意味着调用阶段可以不用传值
2. 位置形参必须放到默认形参的前面
3. 默认形参的值只在定义时赋值一次，定义阶段之后的改动不会影响该值
4. 默认形参的值通常应该是不可变类型
def func(x,z=100,y): #  位置形参必须放到默认形参的前面
    print(x,y,z)

m=10
def func(x,y,z=m):
    #z=10
    print(x,y,z)
m=100 # 默认形参的值只在定义时赋值一次，定义阶段之后的改动不会影响该值
func(1,2)

def add_hobby(name,x,hobbies=[]): # 默认形参的值通常应该是不可变类型
    hobbies.append(x)
    print('%s 的爱好有 %s' %(name,hobbies))

add_hobby('egon练习','read',[])
add_hobby('wxx','eat',[])
add_hobby('alex','piao',[])

正确的做法
def add_hobby(name,x,hobbies=None):
    if hobbies is None:
        hobbies=[]
    hobbies.append(x)
    print('%s 的爱好有 %s' %(name,hobbies))

add_hobby('egon练习','read',)
add_hobby('wxx','eat',)
add_hobby('alex','piao')

4. 可变长参数：
可变长实参：指的是在调用阶段，实参值个数是不固定的,
实参无非两种形式（位置，关键字实参），
  对应着形参也必须有两种解决方案来分别接收溢出位置实参或者关键字实参
*--->溢出的位置实参
**--->溢出的关键字实参

用法
在形参前加*：*会将溢出的位置实参存成元组的形式，然后赋值给*后的形参名
def func(x,y,*z): #z=(3,4,5)
    print(x,y,z)
func(1,2,3,4,5)

在实参前加*：但凡碰到实参中带*的，先将实参打散成位置实参再与形参做对应
func(*[1,2,3,4,5]) #func(1,2,3,4,5)
func(*[1,2,3]) #func(1,2,3)
func(1111,2222,*[1,2,3,4,5]) #func(1111,2222,1,2,3,4,5)

用法
在形参前加**：**会将溢出的关键字实参存成字典的形式，然后赋值给**后的形参名
def func(x,y,**z): #z={'c':3,'b':2,'a':1}
    print(x,y,z)
func(1,y=2,a=1,b=2,c=3)

在实参前加**：但凡碰到实参中带**的，先将实参打散成关键字实参再与形参做对应
def func(x,y,z):
    print(x,y,z)
func(1,**{'y':2,'z':3}) #func(1,z=3,y=2)
func(1,**{'a':2,'y':333,'z':3}) #func(1,a=2,y=333,z=3) # a错误,位置形参必须被传值

def func(x,y,**z):
    print(x,y,z)
func(**{'y':1,'x':2,'a':1111,'b':2222}) #func(y=1,x=2,a=1111,b=2222)

形参中：*args，**kwargs
def func(x,*args):
    print(x)
    print(args)

def func(x,**kwargs):
    print(x)
    print(kwargs)



变量作用域：
根据定义变量的位置，变量分为两种：
局部变量：在函数中定义的变量，包括参数，都被称为局部变量。
全局变量：在函数外面、全局范围内定义的变量，被称为全局变量。
局部作用域：局部变量只能在局部使用
全局作用域：定义在函数外的变量，作用域是整个代码段
嵌套作用域：函数里面嵌套函数，内部函数可以使用外部函数的变量
作用域相关的关键字：当内部作用域想修改外部作用域的变量时，就要用到global即函数内定义全局变量;如果要修改嵌套作用域（enclosing 作用域，外层
非全局作用域）中的变量则需要 nonlocal 关键字了
注：　在函数内部，可以引用全局变量；如果全局和局部都有一个变量，函数查找，由内而外，局部没有，再到全局找

'''


'''
round()--返回浮点数x的四舍五入值。
eg:
'''
# a = round(1.1281,2)
# print(a)

# def add(x, y):
#     result = x+y
#     return result
#
# def print_code(str):
#     print(str)
#
# a = add(1,2)
# b = print_code('hi')
# print(a,b)     因为def print_code()函数里有返回值，所以会返回none

# 让函数返回多个结果：以元祖的方式返回
# eg:

# def power(x,y):
#       power1 = x+3
#       power2 = y*2+10
#       return (power1 , power2)
#
# c  = power(3, 6)
# # 分别返回值
# power1,power2 = power(3,6)  # 序列解包
# print(power1,power2)
# print(type(c))


# 序列解包








